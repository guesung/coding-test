# 문제
https://school.programmers.co.kr/learn/courses/30/lessons/150368

# 1. 문제 파악

- 문제의 요점 : 최대 플러스 가입자 최대, 그리고 판매액 최대 구하기

# 2. 내 풀이

> 알고리즘 : DFS
> 

> 시간복잡도 : `O(4**m)`
> 

```tsx
const DISCOUNT_RATE = [10,20,30,40];
function getDiscountPrice (price,discountRate){
    return price * (1 - 0.01 * discountRate);
}
function solution(users, emoticons) {
    let maxEmoticonPlusUser = 0, maxEmoticonPrice = 0;
    
    function dfs (discountArray) {
        if(discountArray.length === emoticons.length){
            let emoticonPlusUser = 0, emoticonPrice = 0;
            for(const [minDiscount, emoticonPlusPrice] of users){
                let priceSum = 0;
                discountArray.forEach((discountRate,index)=> { // index로 discount에 매칭되는 emoticions에 접근해야 하기에 forEach사용
                    if(discountRate >= minDiscount){
                        const emoticonPrice = emoticons[index]
                        priceSum += getDiscountPrice(emoticonPrice,discountRate);
                    }
                })
                if(priceSum>=emoticonPlusPrice) emoticonPlusUser++;
                else emoticonPrice += priceSum
            }
            if(emoticonPlusUser<maxEmoticonPlusUser) return;
            
            if(emoticonPlusUser === maxEmoticonPlusUser) maxEmoticonPrice = Math.max(maxEmoticonPrice,emoticonPrice)
            else{
                maxEmoticonPlusUser = emoticonPlusUser;
                maxEmoticonPrice = emoticonPrice;
            }
            return;
        }
        for(const discount of DISCOUNT_RATE){
            dfs([...discountArray,discount])
        }
    }
    
    
    dfs([]);
    
    return [maxEmoticonPlusUser,maxEmoticonPrice];
}
```

## 풀이 방법

모든 경우의 수를 탐색해도 시간초과가 걸리지 않을 것이라 판단했다. 그 이유는, emoticons각각 할인 비율의 종류는 4가지(10,20,30,40)이다. 각 비율로 계산했을 때 최대 4 ^ m(emoticons의 길이, 최대 7) = 최대 16384이다. 그 이후로는 단순한 계산이다. 그래서, 모든 경우의 수를 계산하는 DFS혹은 BFS를 고려했다.

중간에 끊낼 수 없고, 끝까지 탐색해서 최대값을 비교해야 하기에 BFS보다는 DFS가 적절하다고 판단했다.